毕业项目
分别用100个字以上的一段话，加上一副图，总结自己对下列技术的关键点的思考和经验认识：
8)分布式缓存
（1）分布式缓存是为了解决数据库服务器和Web服务器之间的瓶颈，如果一个网站流量很大这个瓶颈将会非常明显，每次数据库查询耗费的时间将不容乐观。对于更新速度不是很快的站点，可以采用静态化来避免过多的数据查询，可使用Freemaker或Velocity来实现页面静态化。对于更新数据以秒级的站点，静态化也不会太理想，可通过分布式缓存系统来解决，如Redis、MemCache、SSDB等。
（2）缓存的更新模式
Cache Aside模式
读取失效：cache数据没有命中，查询DB，成功后把数据写入缓存
读取命中：读取cache数据
更新：把数据更新到DB，失效缓存
Read/Write Through模式：缓存代理了DB读取、写入的逻辑，可以把缓存看成唯一的存储。
Write Behind Caching(Write Back)模式：这种模式下所有的操作都走缓存，缓存里的数据再通过异步的方式同步到数据库里面。所以系统的写性能能够大大提升了。
（3）缓存失效策略
一般而言，缓存系统中都会对缓存的对象设置一个超时时间，避免浪费相对比较稀缺的缓存资源。对于缓存时间的处理有两种，分别是主动失效和被动失效。
主动失效是指系统有一个主动检查缓存是否失效的机制，比如通过定时任务或者单独的线程不断的去检查缓存队列中的对象是否失效，如果失效就把他们清除掉，避免浪费。主动失效的好处是能够避免内存的浪费，但是会占用额外的CPU时间。
被动失效是通过访问缓存对象的时候才去检查缓存对象是否失效，这样的好处是系统占用的CPU时间更少，但是风险是长期不被访问的缓存对象不会被系统清除。
（4）缓存淘汰策略
缓存淘汰，又称为缓存逐出，是指在存储空间不足的情况下，缓存系统主动释放一些缓存对象获取更多的存储空间。
先进先出（First In First Out）是一种简单的淘汰策略，缓存对象以队列的形式存在，如果空间不足，就释放队列头部的（先缓存）对象。一般用链表实现。
最近最久未使用（Least Recently Used），这种策略是根据访问的时间先后来进行淘汰的，如果空间不足，会释放最久没有访问的对象（上次访问时间最早的对象）。比较常见的是通过优先队列来实现。
最近最少使用（Least Frequently Used），这种策略根据最近访问的频率来进行淘汰，如果空间不足，会释放最近访问频率最低的对象。这个算法也是用优先队列实现的比较常见。
（5）分布式缓存的常见问题
缓存穿透
DB中不存在数据，每次都穿过缓存查DB，造成DB的压力。一般是网络攻击
解决方案：放入一个特殊对象（比如特定的无效对象，当然比较好的方式是使用包装对象）
缓存击穿
在缓存失效的瞬间大量请求，造成DB的压力瞬间增大
解决方案：更新缓存时使用分布式锁锁住服务，防止请求穿透直达DB
缓存雪崩
大量缓存设置了相同的失效时间，同一时间失效，造成服务瞬间性能急剧下降
解决方案：缓存时间使用基本时间加上随机时间
（6）Redis
Redis是一个开源的面向键值对Key-Value类型数据的分布式NoSQL数据库系统，它的特点是高性能，适用于高并发的应用场景。Redis是一个高性能的KV数据库，并提供多种语言的API。Redis的缺点也很明显，对事务的处理很弱，也无法做太复杂的关系型数据库中的模型。
Redis支持存储的Value类型相对更多，典型的如字符串String、链表List、集合Set、有序集合Zset（sorted set）、哈希类型Hash，这些数据类型都支持push和pop、add和remove，以及取交集、并集、差集等更为复杂的操作。由于这些操作都是原子性的，在此基础上，Redis支持各种不同方式的排序。
与MemCache一样为了保证效率，数据都被缓存在内存中，区别在于Redis会周期性的把更新的数据写入磁盘，或把修改操作写入追加的记录文件中，并且在此基础上实现master-slave主从同步策略，也就是数据可以从主服务器向任意数量的从服务器上同步，从服务器可以关联其他类型的主服务器。因此，Redis的出现很大程度上弥补了MemCahe此类KV存储的不足，在部分场合可以对关系型数据库起到很好的补充作用。
